% Type checker extension for inductive types and recursive functions %%%%%%%%%

% Quantities privided by the environment: I, J, K := integers

% Closed term: T, U, V, W := case W U V A        match V with constructors of W and select branch in A of type U

% Closed term list: A, B  := [] | [V|A]          defined by the system

% Stack: P, Q             := case_frame W U A P  case frame (continuations)

% LIST HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

append (case_frame W U A P1) P2 (case_frame W U A P) :- append P1 P2 P.

forall2 (case_frame W U1 A1 P1) (case_frame W U2 A2 P2) F :- F U1 U2, forall2 A1 A2 F, forall2 P1 P2 F.

% EXTRA REDUCTIONS HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is+constructor V P V P :- get_constructor V _ _.

%

unwind+whd+to+constructor V1 V2 :- unwind+whd+long V1 [] is+constructor V2.
%                                  if on+focus ($print (unwind+whd+to+constructor+end V2)).
%

get+branch (case_frame _ _ A P) J T P [] :- nth A J T.

get+branch [V|P] J T P1 [V|P2] :- get+branch P J T P1 P2.

% EXTRA REDUCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% unwind for case
unwind+stack (case_frame W U A P) V1 V2 :- unwind+stack P (case W U V1 A) V2.

% check constructor before expanding fixpoint
expand T1 P1 P2 :- get_fixpoint T1 L, !,
                   subst P1 L unwind+whd+to+constructor P2
%                , if on+focus ($print global-delta-fix)
                   .
% nu for case
whd+basic (case W U V A) P _ V (case_frame W U A P) :- !.

% iota for case
% note: the left arguments must be removed
whd+basic T1 P1 _ T2 P2 :- get_constructor T1 J K, !,
                           get+branch P1 J T2 P A, split A K SN DX, append DX P P2
%                        , if on+focus ($print iota)
                           .

% drop case frame on t-stack (white register)
unwind+whd+pi T1 P (case_frame _ _ _ Q) T2 :- !, unwind+whd+pi T1 P Q T2.

% VALIDITY + INFERRED TYPE HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mk+out+type W0 U0 V W0 P U0 DXV :- get_inductive W0 K, split P K SN DX,
                                   append DX [V] DXV.

% VALIDITY + INFERRED TYPE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% not complete, we just compute the output type ...
t+step (case W0 U0 V A) U :- !, t+step V W, unwind+whd+long W [] (mk+out+type W0 U0 V) U.
