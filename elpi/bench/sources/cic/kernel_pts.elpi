accumulate logic.
accumulate list.

% Extensible type checker for a generic PTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Level/age/heght: H := integer

% Closed term: T, U, V, W   := sort S        sort S
%                           |  prod     W F  product of type W in F
%                           |  abst     W F  abstraction of type W in F
%                           |  abbr   V W F  abbreviation of V of type W in F
%                           |  appl T A      application of T to list A

% Functional term: F        := function of type T => T

% Closed term list: A, B    := [] | [V|A]  defined by the system

% Stack: P, Q               := []     empty
%                           :  [V|P]  application frame (argument)

% Continuation: C

% Type inclusion mode: M, N := i+sn  lhs may be smaller than rhs
%                           :  i+dx  rhs may be smaller than lhs
%                           :  i+rc  the two sides must be equal

% Predicates: whd+no+delta T P C             multistep weak head reduct of T after P
%                                            without delta-expansion, passed to continuation C
%             unwind+whd+no+delta T1 P1 T2   multistep weak head reduct of T1 after P1 to T2
%                                            without delta-expansion
%             unwind+whd+delta+pi T1 P Q T2  multistep weak head reduction of T1 after P and Q to T2
%                                            with delta-expansion and validating pi-reduction
%             unwind+whd+delta T1 P C T2     multistep weak head reduction with delta-expansion,
%                                            of T1 after P passed to relation C returning T2
%             red+whnf T1 P1 M T2 P2         reducibility test for generic T1 after P1 to whnf of T2 after P2
%             conv+main T1 M T2              convertibility test for generic T1 and T2
%             conv+args P1 P2                convertibility test for generic stacks P1 and P2
%             conv+whnf U1 P1 M U2 P2        convertibility test for whnf's U1 after P1 and U2 after P2
%             r+step+h T1 H X T2             transition to T2 from constant T1 with level/age/heght H
%                                            the call-by-need reduction strategy uses X, that reduces to T2 
%             t+step T U                     inference of a type U for T
%           * has+sort T S                   test for T having sort S
%             has+checked+type T U           test for T having checked type U
%           * has+type T U                   test for T having generic type U

% WEAK HEAD COMPUTATION WITHOUT DELTA-EXPANSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% we delay delta-expansion to possibly avoid it.
% whd+no+delta T P C :- on+focus, $print (whd+no+delta T P), fail.

% normal form for meta-variables.
whd+no+delta T P C :- is_flex T, !, C T P.

% sigma for abbreviation + theta.
whd+no+delta (abbr V W F) P C :- !, pi x\ r+step x V X =>
%                                         if on+focus ($print theta),
                                          whd+no+delta (F x) P C.
% beta.
whd+no+delta (abst W F) [V|P] C :- !,
%                                  if on+focus ($print beta),
                                   whd+no+delta (abbr V W F) P C.

% nu for application.
whd+no+delta (appl T A) P1 C :- !, append A P1 P2,
%                                  if on+focus ($print nu),
                                   whd+no+delta T P2 C.
% hook for extra reductions.
whd+no+delta T1 P1 C :- whd+extra T1 P1 T2 P2, !, whd+no+delta T2 P2 C.

% normal form.
whd+no+delta T P C :- C T P, !.

% WEAK HEAD COMPUTATION WITHOUT DELTA EXPANSION + UNWIND %%%%%%%%%%%%%%%%%%%%%

% unwind+whd+no+delta T1 P1 T2 :- on+focus, $print (unwind+whd+no+delta T1 P1), fail.

% beta.
unwind+whd+no+delta (abst W F) [V|P] T2 :- !,
%                                          if on+focus ($print beta),
                                           unwind+whd+no+delta (abbr V W F) P T2.

% nu for application.
unwind+whd+no+delta (appl T1 A) P1 T2 :- !, append A P1 P2,
%                                        if on+focus ($print nu),
                                         unwind+whd+no+delta T1 P2 T2.
% sigma for abbreviation + theta + zeta.
unwind+whd+no+delta (abbr V1 W F1) P1 Y :- !, pi x\ r+step x V1 X => (
%                                                   if on+focus ($print theta),
                                                    unwind+whd+no+delta (F1 x) P1 (F2 x),
                                                    orelse (F2 x = Y) (r+unwind V1 X V2, abbr V2 W F2 = Y)
                                              ).
% hook for extra reductions.
unwind+whd+no+delta T1 P1 T :- whd+extra T1 P1 T2 P2, !, unwind+whd+no+delta T2 P2 T.

% normal form
unwind+whd+no+delta T1 P1 (appl T2 P2) :- !.

% WEAK HEAD COMPUTATION WITH DELTA EXPANSION AND PI-REDUCTION + UNWIND %%%%%%%

% - aka eat_prods
% - the staks P and Q resamble respectively the registers Yellow and White
%   of de Bruijn validation machine for Delta-Lambda
% unwind+whd+delta+pi T1 P Q T2 :- on+focus, $print (unwind+whd+delta+pi T1 P Q T2), fail.

% reflexivity.
unwind+whd+delta+pi T [] [] T :- !.

% beta.
unwind+whd+delta+pi (abst W F) [V|P] Q T2 :- !,
%                                            if on+focus ($print beta),
                                             unwind+whd+delta+pi (abbr V W F) P Q T2.

% nu for application.
unwind+whd+delta+pi (appl T1 A) P1 Q T2 :- !, append A P1 P2,
%                                          if on+focus ($print nu),
                                           unwind+whd+delta+pi T1 P2 Q T2.
% validating pi.
unwind+whd+delta+pi (prod W F) [] [V|Q] T2 :- !, has+checked+type V W,
                                              unwind+whd+delta+pi (abbr V W F) [] Q T2.

% sigma for abbreviation + theta + zeta.
unwind+whd+delta+pi (abbr V1 W F1) P Q Y :- !, pi x\ r+step x V1 X => (
%                                                    if on+focus ($print theta),
                                                     unwind+whd+delta+pi (F1 x) P Q (F2 x),
                                                     orelse (F2 x = Y) (r+unwind V1 X V2, abbr V2 W F2 = Y)
                                               ).
% delta.
unwind+whd+delta+pi T1 P1 Q T2 :- r+step+h T1 _ X T, !,
                                  r+step+r T1 P1 X T P, unwind+whd+delta+pi T P Q T2.

% hook for extra reductions.
unwind+whd+delta+pi T1 P1 Q T :- whd+extra T1 P1 T2 P2, !, unwind+whd+delta+pi T2 P2 Q T.

% WEAK HEAD COMPUTATION WITH DELTA EXPANSION + UNWIND %%%%%%%%%%%%%%%%%%%%%%%%

% unwind+whd+delta T1 P C T2 :- on+focus, $print (unwind+whd+delta T1 P T2), fail.

% beta.
unwind+whd+delta (abst W F) [V|P] C T2 :- !,
%                                         if on+focus ($print beta),
                                          unwind+whd+delta (abbr V W F) P C T2.

% nu for application.
unwind+whd+delta (appl T1 A) P1 C T2 :- !, append A P1 P2,
%                                       if on+focus ($print nu),
                                        unwind+whd+delta T1 P2 C T2.
% sigma for abbreviation + theta + zeta.
unwind+whd+delta (abbr V1 W F1) P C Y :- !, pi x\ r+step x V1 X => (
%                                                 if on+focus ($print theta),
                                                  unwind+whd+delta (F1 x) P C (F2 x),
                                                  orelse (F2 x = Y) (r+unwind V1 X V2, abbr V2 W F2 = Y)
                                            ).
% delta.
unwind+whd+delta T1 P1 C T2 :- r+step+h T1 _ X T, !,
                               r+step+r T1 P1 X T P, unwind+whd+delta T P C T2.

% hook for extra reductions.
unwind+whd+delta T1 P1 C T :- whd+extra T1 P1 T2 P2, !, unwind+whd+delta T2 P2 C T.

% normal form
unwind+whd+delta T1 P1 C (appl T2 P2) :- C T1 P1 T2 P2, !.

% CONVERSION HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

i+not i+sn i+dx.

i+not i+dx i+sn.

i+not i+rc i+rc.

% red+whnf T1 P1 M U2 P2 :- on+focus, $print (red+whnf T1 P1 M U2 P2), fail.

red+whnf T1 P1 M U2 P2 :- whd+no+delta T1 P1 (conv+whnf U2 P2 M), !.

%

% conv+main T1 M T2 :- on+focus, $print (conv+main T1 M T2), fail.

conv+main T1 M T2 :- whd+no+delta T1 [] (red+whnf T2 [] M), !.

%

% conv+args P1 P2 :- on+focus, $print (conv+args P1 P2), fail.

conv+args [] [] :- !.

conv+args [V1|P1] [V2|P2] :- !, conv+args P1 P2, conv+main V1 i+rc V2.

% CONVERSION OF WHNF'S %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% conv+whnf T1 P1 M T2 P2 :- on+focus, $print (conv+whnf T1 P1 M T2 P2), fail.

% left subsumption for sort
conv+whnf (sort S1) [] i+sn (sort S2) [] :- !, pts+sub S1 S2.

% right subsumption for sort
conv+whnf (sort S1) [] i+dx (sort S2) [] :- !, pts+sub S2 S1.

% reflexivity: fast path for alpha-convertible stacks
conv+whnf T P M T P :- !.
% , if on+focus ($print reflexivity).

% reflexivity: generl case.
conv+whnf T P1 M T P2 :- conv+args P1 P2, !.

% xi for product.
conv+whnf (prod W1 F1) [] M (prod W2 F2) [] :- !, conv+main W1 i+rc W2,
                                               pi x\ conv+main (F1 x) M (F2 x).
% xi for abstraction.
conv+whnf (abst W1 F1) [] M (abst W2 F2) [] :- !, conv+main W1 i+rc W2,
                                               pi x\ conv+main (F1 x) i+rc (F2 x).
% candidate left delta.
conv+whnf T1 P1 M T2 P2 :- r+step+h T1 H1 X1 V1, !, maybe+sn T1 P1 H1 X1 V1 M T2 P2.

% forced right delta.
conv+whnf T1 P1 M T2 P2 :- r+step+h T2 _ X V, !,
                           r+step+r T2 P2 X V P, red+whnf V P M T1 P1.

% AGE/HEIGHT-CONTROLLED DELTA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

maybe+sn T1 P1 H1 X1 V1 M T2 P2 :- r+step+h T2 H2 X2 V2, !, check+h T1 P1 H1 X1 V1 M T2 P2 H2 X2 V2.

% forced left delta.
maybe+sn T1 P1 _ X V M T2 P2 :- i+not M N, r+step+r T1 P1 X V P, red+whnf V P N T2 P2.

%

% age/hight-implied left delta.
check+h T1 P1 H1 X V M T2 P2 H2 _ _ :- lt+h H2 H1, !,
                                       i+not M N, r+step+r T1 P1 X V P, red+whnf V P N T2 P2.

% age/hight-implied right delta.
check+h T1 P1 _ _ _ M T2 P2 _ X V :- r+step+r T2 P2 X V P, red+whnf V P M T1 P1.

%

lt+h H1 H2 :- H1 < 0, H2 < 0, !, H2 < H1.

lt+h H1 H2 :- H1 < H2.

% VALIDITY + INFERRED TYPE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% print_hyps :- t+step X W, on+focus, $print "HYP" X W.

% print_hyp X :- t+step X W, on+focus, $print "HYP" X W.

% t+step T U :- on+focus, $print (t+step T U), fail.

% S.
t+step (sort S1) (sort S2) :- !, pts+pair S1 S2.

% N.
t+step (appl T1 A) T :- !, t+step T1 T2, unwind+whd+delta+pi T2 [] A T.

% Sigma.
t+step (abbr V W F1) (abbr V W F2) :- !, has+type V W,
                                      pi x\ t+step x W => r+step x V X =>
                                      t+step (F1 x) (F2 x).
% X for product.
t+step (prod W F) (sort S3) :- !, has+sort W S1,
                               pi x\ t+step x W => has+sort (F x) S2,
                               pts+triple S1 S2 S3.
% X for abstraction.
t+step (abst W F1) (prod W F2) :- !, has+sort W S1,
                                  pi x\ t+step x W =>
                                        (t+step (F1 x) (F2 x))
%, has+sort (F2 x) S2, pts+triple S1 S2 S3),
                                  .

% TYPE CHECKING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% has+sort T S :- on+focus, $print (has+sort T S), fail.

% fast path for T being a sort.
has+sort (sort S1) S2 :- t+step (sort S1) (sort S2), !.

% fast path for T being a subsumed sort.
has+sort (sort S1) S2 :- !, t+step (sort S1) (sort S), pts+sub S S2.

has+sort T S :- t+step T U, red+whnf U [] i+dx (sort S) [].

%

% has+checked+type T U :- on+focus, $print (has+checked+type T U), fail.

% fast path for U being a sort.
has+checked+type T (sort S) :- !, has+sort T S.

has+checked+type T U :- t+step T X,
%                       if on+focus ($print conversion),
                        conv+main X i+sn U, !.

%

% has+type T U :- on+focus, $print (has+type T U), fail.

% fast path for U being a sort.
has+type T (sort S) :- !, has+sort T S.

% was: has+sort U S
has+type T U :- t+step U _S, has+checked+type T U, !.

% KERNEL HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

r+step+h T1 H T T2 :- r+step T1 T T2, !, $level T1 H.

%

% r+step+r T1 P1 T T2 P2 :- on+focus, $print (r+step+r T1 P1 T T2 P2), fail.

r+step+r T1 P1 T T2 P2 :- set+t2 T T2, set+p2 T1 P1 P2, !.

%

% set+t2 T T2 :- is_flex T2, !, unwind+whd+no+delta T [] T2.

set+t2 T T2 :- T = T2, !.

%

% hook for extra checks before delta
set+p2 T1 P1 P2 :- r+step+extra T1 P1 P2, !.

set+p2 _ P1 P1 :- !.

%

% :- is_flex T2.
r+unwind T1 T2 T1 :- !.

% r+unwind T1 T2 T2 :- !.

%

pts+triple S1 S2 S2 :- pts+couple S1 S2, !.
