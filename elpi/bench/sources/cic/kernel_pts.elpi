% Type checker for a generic PTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Level/age/heght: H := integer

% Closed term: T, U, V, W   := sort S      sort S
%                           |  prod W   F  product of type W in F
%                           |  abst W   F  abstraction of type W in F
%                           |  abbr W V F  abbreviation of V of type W in F
%                           |  appl T A    application of T to list A

% Functional term: F        := function of type T => T

% Closed term list: A, B    := [] | [V|A]  defined by the system

% Stack: P, Q               := []     empty
%                           :  [V|P]  application frame (argument)

% Continuation: C

% Mode: M, N := on+conv  delta-expansion: just local
%            :  on+whd   delta-expansion: local and global
%            :  on+sub   type inclusion:  lhs may be smaller than rhs
%            :  on+eq    type inclusion:  the two sides must be equal

% Predicates: unwind+whd+l+delta T1 P1 T2    multistep weak head reduct of T1 after P1 to T2
%                                            with local delta-expansion
%             unwind+whd+delta+pi T1 P Q T2  multistep weak head reduction of T1 after P and Q to T2
%                                            with delta-expansion and validating pi-reduction
%             unwind+whd+delta T1 P C T2     multistep weak head reduction with delta-expansion,
%                                            of T1 after P passed to relation C returning T2
%             conv+top T1 M T2               convertibility test for generic T1 and T2
%             conv+main T1 P1 M T2 P2        convertibility test for generic T1 after P1 and T2 after P2
%             conv+args P1 P2                convertibility test for generic stacks P1 and P2
%             conv+main U1 P1 M U2 P2        convertibility test for whnf's U1 after P1 and U2 after P2
%             r+step+h T1 H X T2             transition to T2 from constant T1 with level/age/heght H
%                                            the call-by-need reduction strategy uses X, that reduces to T2 
%             t+step T U                     inference of a type U for T
%           * has+sort T S                   test for T having type (sort S)
%             has+checked+type T U           test for T having checked type U
%           * has+type T U                   test for T having generic type U

% CONSTRUCTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mk+appl T [] T :- !.

mk+appl T A (appl T A) :- !.

% DELTA-EXPANSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

r+step+h T1 H T T2 :- r+step T1 T T2, !, level T1 H.

%

r+unwind T1 _T2 T1 :- /* is_flex _T2, */ !.

% r+unwind T1 T2 T2 :- !.

% BASIC WEAK HEAD REDUCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% beta
whd+basic (abst W F) [V|P] M (abbr W V F) P :- !
%                                            , if on+focus ($print beta)
                                               .
% nu for application.
whd+basic (appl T A) P1 M T P2 :- !, append A P1 P2
%                               , if on+focus ($print nu)
                                  .
% local delta.
whd+basic T1 P1 on+conv T2 P2 :- r+step+h T1 H X T2, H >= 0, !,
                                 r+step+r T1 P1 X T2 P2.
% local delta + global delta.
whd+basic T1 P1 on+whd T2 P2 :- r+step+h T1 _ X T2, !,
                                r+step+r T1 P1 X T2 P2.

% RESTRICTED WEAK HEAD COMPUTATION FOR CONVERSION + UNWIND %%%%%%%%%%%%%%%%%%%

% basic reductions.
unwind+whd+l+delta T1 P1 T :- whd+basic T1 P1 on+conv T2 P2, !, unwind+whd+l+delta T2 P2 T.

% sigma for abbreviation + theta + zeta.
unwind+whd+l+delta (abbr W V1 F1) P1 Y :- !, pi x\ r+step x V1 X => (
%                                                  if on+focus ($print theta),
                                                   unwind+whd+l+delta (F1 x) P1 (F2 x),
                                                   orelse (F2 x = Y) (r+unwind V1 X V2, abbr W V2 F2 = Y)
                                             ).
% normal form
unwind+whd+l+delta T1 P1 T2 :- !, mk+appl T1 P1 T2.

% FULL WEAK HEAD COMPUTATION WITH PI-REDUCTION + UNWIND %%%%%%%%%%%%%%%%%%%%%%
% - aka eat_prods
% - the stacks P and Q resamble respectively the registers Yellow and White
%   of de Bruijn validation machine for Delta-Lambda

% reflexivity.
unwind+whd+delta+pi T [] [] T :- !.

% basic reductions.
unwind+whd+delta+pi T1 P1 Q T :- whd+basic T1 P1 on+whd T2 P2, !, unwind+whd+delta+pi T2 P2 Q T.

% validating pi.
unwind+whd+delta+pi (prod W F) [] [V|Q] T2 :- !, has+checked+type V W,
                                              unwind+whd+delta+pi (abbr W V F) [] Q T2.

% sigma for abbreviation + theta + zeta.
unwind+whd+delta+pi (abbr W V1 F1) P Q Y :- !, pi x\ r+step x V1 X => (
%                                                    if on+focus ($print theta),
                                                     unwind+whd+delta+pi (F1 x) P Q (F2 x),
                                                     orelse (F2 x = Y) (r+unwind V1 X V2, abbr W V2 F2 = Y)
                                               ).

% FULL WEAK HEAD COMPUTATION + UNWIND %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% basic reductions.
unwind+whd+delta T1 P1 C T :- whd+basic T1 P1 on+whd T2 P2, !, unwind+whd+delta T2 P2 C T.

% sigma for abbreviation + theta + zeta.
unwind+whd+delta (abbr W V1 F1) P C Y :- !, pi x\ r+step x V1 X => (
%                                                 if on+focus ($print theta),
                                                  unwind+whd+delta (F1 x) P C (F2 x),
                                                  orelse (F2 x = Y) (r+unwind V1 X V2, abbr W V2 F2 = Y)
                                            ).
% normal form
unwind+whd+delta T1 P1 C T :- C T1 P1 T2 P2, !, mk+appl T2 P2 T.

% CONVERSION HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv+eq T1 T2 :- conv+main T1 [] on+eq T2 [], !.

conv+sub T1 T2 :- conv+main T1 [] on+sub T2 [], !.

% CONVERSION OF WHNF'S %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% reflexivity: fast path for alpha-convertible stacks
conv+main T P _ T P :- ! /* , if on+focus ($print reflexivity) */.

% left subsumption for sort
conv+main (sort S1) [] on+sub (sort S2) [] :- !, pts+sub S1 S2.

% reflexivity: generl case.
conv+main T P1 _ T P2 :- forall2 P1 P2 conv+eq, !.

% left basic reductions.
conv+main T1 P1 M T2 P2 :- whd+basic T1 P1 on+conv T P, !, conv+main T P M T2 P2.

% left sigma for abbreviation + theta.
conv+main (abbr _ V1 F1) P1 M T2 P2 :- !, pi x\ r+step x V1 _ =>
%                                      if on+focus ($print theta),
                                       conv+main (F1 x) P1 M T2 P2.

% right basic reductions.
conv+main T1 P1 M T2 P2 :- whd+basic T2 P2 on+conv T P, !, conv+main T1 P1 M T P.

% right sigma for abbreviation + theta.
conv+main T1 P1 M (abbr _ V2 F2) P2 :- !, pi x\ r+step x V2 _X =>
%                                      if on+focus ($print theta),
                                       conv+main T1 P1 M (F2 x) P2.
% xi for product.
conv+main (prod W1 F1) [] M (prod W2 F2) [] :- !, conv+eq W1 W2,
                                               pi x\ conv+main (F1 x) [] M (F2 x) [].
% xi for abstraction.
conv+main (abst W1 F1) [] _M (abst W2 F2) [] :- !, conv+eq W1 W2,
                                                pi x\ conv+eq (F1 x) (F2 x).

% VALIDITY + INFERRED TYPE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% S.
t+step (sort S1) (sort S2) :- !, pts+pair S1 S2.

% N.
t+step (appl T1 A) T :- !, t+step T1 T2, unwind+whd+delta+pi T2 [] A T.

% Sigma.
t+step (abbr W V F1) (abbr W V F2) :- !, has+type V W,
                                      pi x\ (t+step x W :- !) => r+step x V _X =>
                                      t+step (F1 x) (F2 x).
% X for product.
t+step (prod W F) (sort S3) :- !, has+sort W S1,
                               pi x\ (t+step x W :- !) => has+sort (F x) S2,
                               pts+triple S1 S2 S3.
% X for abstraction.
t+step (abst W F1) (prod W F2) :- !, has+sort W _S1,
                                  pi x\ (t+step x W :- !) =>
                                        (t+step (F1 x) (F2 x))
%, has+sort (F2 x) S2, pts+triple S1 S2 S3),
                                  .

% TYPE CHECKING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% fast path for T being a sort.
% has+sort (sort S1) S2 :- t+step (sort S1) (sort S2), !.

% fast path for T being a subsumed sort.
% has+sort (sort S1) S2 :- !, t+step (sort S1) (sort S), pts+sub S S2.

has+sort T S :- t+step T X, conv+eq X (sort S), !. 

%

% fast path for U being a sort.
% has+checked+type T (sort S) :- !, has+sort T S.

has+checked+type T U :- t+step T X,
%                       if on+focus ($print conversion),
                        conv+sub X U, !.
%

% fast path for U being a sort.
% has+type T (sort S) :- !, has+sort T S.

% was: has+sort U S
has+type T U :- t+step U _S, has+checked+type T U, !.

% KERNEL HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pts+triple S1 S2 S2 :- pts+couple S1 S2, !.
