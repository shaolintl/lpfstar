% ADDITIONAL CONVERSION FRAMEWORK FOR CHECKING A CASE BRANCH %%%%%%%%%%%%%%%%%
% documentation in kernel.txt.

% conv2_sn T1 S1 P1 M T2 S2 P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type conv2_sn term -> stack -> stack -> conversion_mode -> term -> stack -> stack -> prop.

conv2_sn T1 S1 P1 M T2 S2 P2 :-
  steps T1 S1 P1 on_long (T\ S\ P\ conv2_whnf T S P M T2 S2 P2).

% conv2_dx T1 S1 P1 M T2 S2 P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type conv2_dx term -> stack -> stack -> conversion_mode -> term -> stack -> stack -> prop.

conv2_dx T1 S1 P1 M T2 S2 P2 :-
  steps T2 S2 P2 on_long (T\ S\ P\ conv2_whnf T1 S1 P1 M T S P).

% conv2_main T1 S1 P1 M T2 S2 P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type conv2_main term -> stack -> stack -> conversion_mode -> term -> stack -> stack -> prop.

conv2_main T1 S1 P1 M T2 S2 P2 :-
  steps T1 S1 P1 on_long (T\ S\ P\ conv2_dx T S P M T2 S2 P2).

% conv2_whnf T1 S1 P1 M T2 S2 P2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% removing left product (on_case_branch).
conv2_whnf (prod W1 F1) [] [] (on_case_branch V0 K U0 [V|SN]) U2 S2 [] :- !,
  pi x\ dec x W1 => def x on_no V [] [] =>
    conv2_sn (F1 x) [] [] (on_case_branch V0 K U0 SN) U2 S2 [].

% xi for right product (on_case_branch).
conv2_whnf (prod W1 F1) [] [] (on_case_branch V0 K U0 []) (prod W2 F2) [] [] :- !,
  conv_eq W1 W2, pi x\ dec x W1 =>
    conv2_main (F1 x) [] [] (on_case_branch (appl V0 x) K U0 []) (F2 x) [] [].

% final checks (on_case_branch).
conv2_whnf _ S1 [] (on_case_branch V K U []) U2 S2 [] :-
  split S1 K _ DX, append DX [V] DXV, conv_main U DXV [] on_eq U2 S2 [].

% conv_case_type T1 S1 S2 T2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type conv_case_branch term -> term -> int -> stack -> term -> term -> prop.

conv_case_branch T1 V0 K SN U0 T2 :-
  conv2_main T1 [] [] (on_case_branch V0 K U0 SN) T2 [] [].
