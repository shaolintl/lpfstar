accumulate kernel_pts.

% type checker extension managing Matita interface %%%%%%%%%%%%%%%%%%%%%%%%%%%

% Quantities privided by Matita: I, J, K := integers

% Closed term: T, U, V, W := case V A W U  match V with constructors of W and select branch in A of type U

% Stack: P, Q := cframe A W U P  case frame (continuations)

% LIST HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

append (cframe A W U P1) P2 (cframe A W U P) :- append P1 P2 P.

% EXTRA REDUCTIONS HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is+constructor V P V P :- $constructor V _ _.

%

% unwind+whd+to+constructor V1 V2 :- on+focus, $print (unwind+whd+to+constructor+begin V1), fail.

unwind+whd+to+constructor V1 V2 :- unwind+whd+delta V1 [] is+constructor V2.
%                                  xor (not on+focus) ($print (unwind+whd+to+constructor+end V2)).
%

get+branch J (cframe A _ _ P) T P [] :- nth A J T.

get+branch J [V|P] T P1 [V|P2] :- get+branch J P T P1 P2.

% EXTRA REDUCTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% extra delta
r+step+h T1 H T2 T2 :- $r+step+h T1 H T2, !.

% check constructor before expanding fixpoint
r+step+extra T1 P1 P2 :- $fixpoint T1 L, !,
                         subst P1 L unwind+whd+to+constructor P2.
%                        xor (not on+focus) ($print global-delta-fix).

% nu for case
whd+extra (case V A W U) P V (cframe A W U P) :- !.

% iota for case
% note: the left arguments must be removed
whd+extra T1 P1 T2 P2 :- $constructor T1 J K, !,
%                        xor (not on+focus) ($print iota),
                         get+branch J P1 T2 P A, split A K SN DX, append DX P P2.

% case frame on t-stack (white register) is dropped
unwind+whd+delta+pi T1 P (cframe _ _ _ Q) T2 :- !, unwind+whd+delta+pi T1 P Q T2.

% CONVERSION HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv+args (cframe A1 W U1 P1) (cframe A2 W U2 P2) :- !, conv+args P1 P2,
                                                     conv+main U1 i+rc U2, conv+args A1 A2.

% VALIDITY + INFERRED TYPE HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mk+out+type V W0 U0 W0 P U0 DXV :- $inductive W0 K, split P K SN DX,
                                   append DX [V] DXV.

% VALIDITY + INFERRED TYPE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% not complete, we just compute the output type ...
t+step (case V A W0 U0) U :- !, t+step V W, unwind+whd+delta W [] (mk+out+type V W0 U0) U.

t+step T U :- $t+step T U, !.
