whd1 (app M N) S K :- K [] M [N|S].
whd1 (lam T F1) [N|NS] K :- pi x \ val x T N NF => K [x] (F1 x) NS.
whd1 X S K :- val X _ N NF, orelse (not ($is_flex NF)) (whd_unwind N NF), K [] NF S.

whd* T1 S1 K :- whd1 T1 S1 (vl1 \ t1 \ s1 \ whd* t1 s1 (vl2 \ t2 \ s2 \ sigma VL \ append vl1 vl2 VL, K VL t2 s2)), !.
whd* T1 S1 K :- K [] T1 S1.

whd_unwind N NF :- whd* N [] (l \ t \ s \ sigma TS \ appn s t TS, put_abbr l TS NF).

appn [] T T.
appn [X|XS] T O :- appn XS (app T X) O.

put_abbr [] NF NF.
put_abbr [X|XS] I (abbr T N K) :- val X T N _, put_abbr XS I (K X).

% =====================================
orelse A B :- A, !.
orelse A B :- B.

append [] L L.
append [X|XS] L [X|XSL] :- append XS L XSL.
