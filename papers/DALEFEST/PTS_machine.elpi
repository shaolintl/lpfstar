type conv term -> term -> prop.
type sub term -> term -> prop.

type convm term -> list term -> term -> list term -> prop.

conv T1 T2 :- convm T1 [] T2 [].

type whd1 term -> list term -> (list var -> term -> list term -> prop) -> prop.

% KAM-like rules in CPS style
whd1 (app M N) S K :- K [] M [N|S].
whd1 (lam T F1) [N|NS] K :- pi x \ val x T N NF => K [x] (F1 x) NS.
whd1 X S K :- val X _ N NF, orelse (not ($is_flex NF)) (whd_unwind N NF), K [] NF S.

% Reflexive, transitive closure
whd* T1 S1 K :- whd1 T1 S1 (vl1 \ t1 \ s1 \ whd* t1 s1 (vl2 \ t2 \ s2 \ sigma VL \ append vl1 vl2 VL, K VL t2 s2)), !.
whd* T1 S1 K :- K [] T1 S1.

% Whd followed by machine unwinding.
type whd_unwind term -> term -> prop.
whd_unwind N NF :-
 whd* N [] (l \ t \ s \ sigma TS \ unwind_stack s t TS, put_abbr l TS NF).

% unwind_stack takes an head and a stack and decodes them to a term
unwind_stack [] T T.
unwind_stack [X|XS] T O :- unwind_stack XS (app T X) O.

% put_abbr takes a list of variables and a term and wraps the latter
% with local definitions for the variables in the list
put_abbr [] NF NF.
put_abbr [X|XS] I (abbr T N K) :- val X T N _, put_abbr XS I (K X).

% fast path rule
convm T1 S1 T1 S1 :- !.
% congruence + fast path rule
convm X S1 X S2 :- forall2 S1 S2 conv, !.
% congruence rules
convm (lam T1 F1) [] (lam T2 F2) [] :- conv T1 T2, pi x \ conv (F1 x) (F2 x).
convm (arr T1 F1) [] (arr T2 F2) [] :- conv T1 T2, pi x \ conv (F1 x) (F2 x).
% reduction rules
convm T1 S1 T2 S2 :- whd1 T1 S1 (_ \ t1 \ s1 \ convm t1 s1 T2 S2), !.
convm T1 S1 T2 S2 :- whd1 T2 S2 (_ \ t2 \ s2 \ convm T1 S1 t2 s2).

type subm term -> list term -> term -> list term -> prop.

sub T1 T2 :- whd* T1 [] (_ \ t1 \ s1 \ whd* T2 [] (_ \ subm t1 s1)).
subm T1 S1 T2 S2 :- convm T1 S1 T2 S2.
subm (sort I) [] (sort J) [] :- lt I J.
subm (arr A1 F1) [] (arr A2 F2) [] :- conv A1 A2, pi x\ sub (F1 x) (F2 x).

% =====================================
orelse A B :- A, !.
orelse A B :- B.

append [] L L.
append [X|XS] L [X|XSL] :- append XS L XSL.

forall2 [] [] _.
forall2 [X|XS] [Y|YS] P :- P X Y, forall2 XS YS P.
