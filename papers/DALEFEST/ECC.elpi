% vim:set ft=lprolog:

spy P :- $print "----<<---- enter: " {$counter "run"} P, P, $print "---->>---- exit: " P, !.
spy P :- $print "---->>---- fail: " P, fail.

% of X Y :- $print (of X Y), fail.
% sub X Y :- $print (sub X Y), fail.
% sub-whd X Y :- $print (sub-whd X Y), fail.
% conv X Y :- $print (conv X Y), fail.
% whd* X Y :- $print (whd* X Y), fail.
% whd1 X Y :- $print (whd1 X Y), fail.
% max A B C :- $print (max A B C), fail.

kind term type.
type app term -> term -> term.
type lam term -> (term -> term) -> term.

type whd* term -> term -> prop.
type whd1 term -> term -> prop.

whd1 (app M N) R :- whd* M (lam _ F), whd* (F N) R.
whd* A B :- whd1 A A1, !, whd* A1 B.
whd* X X.

type conv term -> term -> prop.

conv X X.
conv (app M1 N1) (app M2 N2) :- conv M1 M2, conv N1 N2.
conv (lam _ F1) (lam _ F2) :- pi x\ conv (F1 x) (F2 x).
conv A B :- whd1 A A1, conv A1 B.
conv A B :- whd1 B B1, conv A B1.


type sub term -> term -> prop.
type sub-whd term -> term -> prop.
sub A B :- whd* A A1, whd* B B1, sub-whd A1 B1, !.
sub-whd A B :- conv A B.
sub-whd (sort I) (sort J) :- I < J.
sub-whd (arr A1 F1) (arr A2 F2) :- conv A1 A2, pi x\ sub (F1 x) (F2 x).

type of term -> term -> prop.
type arr term -> (term -> term) -> term.

of (app M N) BN :-
  of M TM, conv TM (arr A1 Bx), of N A2, sub A2 A1, BN = Bx N.
of (lam A F) (arr A B) :-
  of A (sort I),
  (pi x\ of x A => of (F x) (B x)),
  of (arr A B) _. % can't put this early, since B flexible

type sort int -> term.

of (sort I) (sort J) :- succ I J.
of (arr A Bx) (sort K) :-
  of A TA, (pi x\ of x A => of (Bx x) TB),
  conv TA (sort I), conv TB (sort J), max I J K.



of nat (sort 0).
of o nat.
of s (app (lam (sort 0) x\ x) (arr nat _\ nat)). % redex
succ  I J :- J is I + 1.
max N M M :- N =< M.
max N M N :- M < N.


main :-
  P1 = (lam (sort 1) t\ lam t x\ x),
  of P1 P1T, $print 1 P1T, !,
  P2 = (app (app P1 nat) (app s o)),
  of P2 P2T, $print 2 P2T, !,
  P3 = (app (app P1 (app (app P1 (sort 0)) nat)) (app s o)), % redex
  of P3 P3T, $print 3 P3T, !,
  true.
